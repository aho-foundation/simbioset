# Автоматическая классификация в Weaviate

## Как работает автоматическая классификация в Weaviate

Weaviate поддерживает несколько типов автоматической классификации данных:

### 1. Contextual Classification (Контекстуальная классификация)

**Принцип работы:**
- Использует векторные представления для классификации
- Классифицирует объекты на основе их семантической близости к примерам классов
- Не требует обучения модели - работает "из коробки"

**Как это работает:**
```python
# 1. Определяем схему с классами
schema = {
    "class": "Paragraph",
    "properties": [
        {"name": "content", "dataType": ["text"]},
        {"name": "classification", "dataType": ["string"]}
    ],
    "vectorizer": "text2vec-openai"  # или другой модуль
}

# 2. Добавляем примеры для каждого класса
# Weaviate использует эти примеры для классификации новых объектов

# 3. При добавлении нового объекта, Weaviate автоматически:
#    - Создает векторное представление
#    - Сравнивает с векторами примеров классов
#    - Присваивает класс на основе ближайших примеров
```

**Преимущества:**
- ✅ Не требует обучения
- ✅ Работает с любыми классами
- ✅ Использует семантическое понимание (векторные представления)

**Недостатки:**
- ⚠️ Нужны примеры для каждого класса
- ⚠️ Точность зависит от качества примеров

### 2. Zero-shot Classification (Классификация без обучения)

**Принцип работы:**
- Использует предобученные модели (например, BERT)
- Классифицирует на основе описания классов
- Не требует примеров

**Как это работает:**
```python
# 1. Определяем классы с описаниями
classes = {
    "ecosystem_risk": "Параграф описывает проблемы или риски в экосистеме",
    "ecosystem_vulnerability": "Параграф описывает уязвимости экосистемы",
    "suggested_ecosystem_solution": "Параграф предлагает решения для экосистемы"
}

# 2. Weaviate использует предобученную модель для классификации
#    Модель понимает семантику описаний классов и текста
```

**Преимущества:**
- ✅ Не требует примеров
- ✅ Работает с описаниями классов
- ✅ Быстрая настройка

**Недостатки:**
- ⚠️ Может быть менее точной, чем contextual classification
- ⚠️ Зависит от качества описаний классов

### 3. NER (Named Entity Recognition) модули

**Принцип работы:**
- Автоматически извлекает именованные сущности из текста
- Поддерживает различные типы сущностей (организмы, локации, экосистемы)

**Пример:**
```python
# Weaviate автоматически извлекает:
# - Организмы: "пчела", "цветок", "дерево"
# - Локации: "Москва", "лес", "озеро"
# - Экосистемы: "лесная экосистема", "водная экосистема"
```

## Сравнение с текущей реализацией

### Текущая реализация (LLM-based)

```python
# api/classify/tag_service.py
async def suggest_tags_for_paragraph(
    self, paragraph_content: str, existing_tags: Optional[List[str]] = None
) -> List[str]:
    # Использует LLM для классификации
    # Загружает промпт с описанием тегов
    # LLM анализирует параграф и предлагает теги
```

**Как работает:**
1. Загружает список доступных тегов из БД
2. Формирует промпт с описанием тегов и параграфом
3. Отправляет в LLM для анализа
4. Получает предложенные теги

**Преимущества:**
- ✅ Гибкость - можно описать любые теги
- ✅ Контекстное понимание через LLM
- ✅ Множественные теги одновременно

**Недостатки:**
- ⚠️ Медленнее (нужен запрос к LLM)
- ⚠️ Дороже (токены LLM)
- ⚠️ Зависит от доступности LLM

### Weaviate Classification

**Как работает:**
1. Векторизует параграф через text2vec модуль
2. Сравнивает с векторами примеров классов
3. Присваивает класс на основе ближайших примеров

**Преимущества:**
- ✅ Быстрее (локальная векторизация)
- ✅ Дешевле (нет запросов к LLM)
- ✅ Работает офлайн

**Недостатки:**
- ⚠️ Нужны примеры для каждого класса
- ⚠️ Менее гибко, чем LLM

## Гибридный подход: Weaviate + LLM

### Рекомендуемая архитектура

```
┌─────────────────────────────────────────┐
│         Paragraph Input                 │
└─────────────────────────────────────────┘
                  │
        ┌─────────┴─────────┐
        │                   │
        ▼                   ▼
┌──────────────┐   ┌──────────────┐
│  Weaviate    │   │     LLM      │
│              │   │              │
│ Быстрая      │   │ Точная       │
│ классификация│   │ классификация│
│              │   │              │
│ - Базовые    │   │ - Сложные    │
│   теги       │   │   теги       │
│ - Частые     │   │ - Редкие     │
│   случаи     │   │   случаи     │
└──────────────┘   └──────────────┘
        │                   │
        └─────────┬─────────┘
                  │
        ┌─────────▼─────────┐
        │  Merge Results    │
        │  (объединение)    │
        └───────────────────┘
```

### Реализация

```python
async def classify_paragraph_hybrid(
    paragraph: Paragraph,
    weaviate_client,
    tag_service
) -> Paragraph:
    """Гибридная классификация: Weaviate + LLM"""
    
    # 1. Быстрая классификация через Weaviate
    weaviate_tags = weaviate_client.classify(
        text=paragraph.content,
        classes=["ecosystem_risk", "ecosystem_vulnerability", "suggested_ecosystem_solution"]
    )
    
    # 2. Если Weaviate уверен (высокий score) - используем результат
    if weaviate_tags and weaviate_tags[0].confidence > 0.8:
        paragraph.tags = [weaviate_tags[0].class_name]
        return paragraph
    
    # 3. Иначе используем LLM для точной классификации
    llm_tags = await tag_service.suggest_tags_for_paragraph(
        paragraph.content,
        existing_tags=weaviate_tags
    )
    
    # 4. Объединяем результаты
    paragraph.tags = list(set(weaviate_tags + llm_tags))
    
    return paragraph
```

## Интеграция Weaviate в проект

### Вариант 1: Замена текущей классификации

**Преимущества:**
- Быстрее и дешевле
- Работает офлайн

**Недостатки:**
- Нужны примеры для каждого тега
- Менее гибко

### Вариант 2: Гибридный подход (Рекомендуется)

**Преимущества:**
- Быстро для частых случаев (Weaviate)
- Точно для сложных случаев (LLM)
- Оптимальный баланс скорости и точности

**Реализация:**

```python
class HybridClassificationService:
    """Гибридная классификация: Weaviate для быстрых случаев, LLM для сложных"""
    
    def __init__(self, weaviate_client, tag_service):
        self.weaviate = weaviate_client
        self.tag_service = tag_service
        self._setup_weaviate_classes()
    
    def _setup_weaviate_classes(self):
        """Настраивает классы в Weaviate с примерами"""
        # Загружаем примеры из БД
        examples = self.tag_service.get_tag_examples()
        
        for tag in examples:
            # Добавляем примеры в Weaviate для каждого тега
            self.weaviate.add_class_examples(
                class_name=tag["name"],
                examples=tag["examples"]
            )
    
    async def classify(self, paragraph: Paragraph) -> Paragraph:
        """Классифицирует параграф гибридным методом"""
        
        # 1. Быстрая классификация через Weaviate
        weaviate_result = self.weaviate.classify(
            text=paragraph.content,
            classes=self._get_active_tags()
        )
        
        # 2. Если уверенность высокая - используем результат
        if weaviate_result and weaviate_result.confidence > 0.8:
            paragraph.tags = [weaviate_result.class_name]
            return paragraph
        
        # 3. Иначе используем LLM
        llm_tags = await self.tag_service.suggest_tags_for_paragraph(
            paragraph.content
        )
        paragraph.tags = llm_tags
        
        # 4. Обновляем примеры в Weaviate для обучения
        if llm_tags:
            self.weaviate.add_class_example(
                class_name=llm_tags[0],
                example=paragraph.content[:200]
            )
        
        return paragraph
```

## Выводы

### Когда использовать Weaviate классификацию:

1. **Частые случаи** - когда есть много примеров для классов
2. **Быстрая классификация** - когда скорость важнее точности
3. **Офлайн работа** - когда нужна работа без LLM

### Когда использовать LLM классификацию:

1. **Сложные случаи** - когда нужна высокая точность
2. **Редкие теги** - когда мало примеров
3. **Гибкость** - когда нужно описать классы текстом

### Рекомендация для проекта:

**Гибридный подход:**
- Weaviate для частых тегов (ecosystem_risk, ecosystem_vulnerability)
- LLM для редких и сложных тегов
- Автоматическое обучение Weaviate на примерах из LLM

Это даст оптимальный баланс скорости и точности.
